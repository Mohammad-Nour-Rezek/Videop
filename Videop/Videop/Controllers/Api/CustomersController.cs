using AutoMapper;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Web.Http;
using Videop.DTO;
using Videop.Models;

namespace Videop.Controllers.Api
{
    // also if you want to see json return format we can use postman for test
    // To make a json request:
    // go to post man and give it content-type: application/json in header
    // make post req with user object that return from get req [make sure to remove id cus it nust be new=0]
    // then send and it will return new user with new id, and ok response code [200]

    // To test go to /customers, and this will return an xml object
    // so .net api have 'Media Formatter' so what we return from an action (list of customers)
    // will be formatted base on what the client ask [this is in the header of the req (content-type: application/xml)] if we don't set this value it will be xml by default

    // DTO (Data Transfare Object):
    // because api recieve or return customer objects, this customer objects is part of the domain model of our app
    // it considered implementation deatil which can change frequently as we implement new feature in our app
    // and these changes can potentialy break existing clients that are dependant on customer object
    // ex: if we remove or rename prop this can impact the clients that are dependant on that property
    // so we want to make the contract of this api as stable as possible
    // now to solve this issue we need DTO, this is plain DataStructure used to transfare data from clint to server and vice versa cuz it's name Data trans obj
    // by creating DTO we reduce the chances over api breaking as we refactor domain model
    // changing this DTO can be costly, so we must plan aproper strategy the cost in space of api versioning (not in this course)
    // another issue is by using domain model here (customer) it's open security holes in our app, a hacker can pass additional data to domain model via json obj, by use DTO we can just put prop that must be updated

    // Now anywhere we return a customer object we need to mapped it to DTO first and in methods we need mappin DTO back to customer obj
    // so we will use AutoMapper: in pmc --> install-package automapper
    // in AppStart Create class MappingProfile

    // Api Controller
    public class CustomersController : ApiController
    {
        // We will use context to get customer from DB
        private ApplicationDbContext _context;
        //private readonly IMapper _mapper;        

        // Must use dependency injection framework to get initializeation value, framework: Unity
        public CustomersController()
        {
            _context = new ApplicationDbContext();            
        }

        // Get the list of customers (list of objects)
        // GET: /api/customers
        public IEnumerable<CustomerDTO> GetCustomers()
        {
            // Use .select(pass a delegate that does the mapping) for get collection of objects, remove [()] from Map<>() cuz we will not call this method it's just a reference [Delegate]
            return _context.Customers.ToList().Select(Mapper.Map<Customer, CustomerDTO>);
        }

        // Get: /api/customers/1
        public IHttpActionResult GetCustomer(int id)
        {
            var customer = _context.Customers.SingleOrDefault(c => c.Id == id);

            if (customer == null)
            {
                // Take enumeration that specify the kind of error
                // This is part of the RESTful convention, so if the specific resource not found
                // we return a standard http respnse not found [404]
                //throw new HttpResponseException(HttpStatusCode.NotFound);
                return NotFound();
            }

            // Return one customer object as CustomerDTO
            return Ok(Mapper.Map<Customer, CustomerDTO>(customer));
        }

        // We post a customer to a customer collection 
        // By convention when we create a resource we return the newly created resource to the client
        // because that newly created resource propably have an id that generated by the server
        // POST: /api/customers
        // So this customer obj parameter will be in the request body and asp.net framework will automatically initialize this
        [HttpPost]
        // or by convention insted by the name Post[name]: PostCustomer, and then don't use [HttpPost]

        // Now by conventions of REST when create a resource must return 201 --> created not 200 --> seccesfull
        // so we must return IHttpActionResult, this interface similar to ActionResult in mvc framework
        // and here in ApiController we have bunch of classes that implement this interface
        public IHttpActionResult CreateCustomer(CustomerDTO customerDTO)
        {
            if (!ModelState.IsValid)
            {
                // By convention server error [400]
                //throw new HttpResponseException(HttpStatusCode.BadRequest);
                // insted use the helper method
                return BadRequest();
            }


            // Here it create a new obj and return it so it's not need second parameter in ()
            Customer customer = Mapper.Map<CustomerDTO, Customer>(customerDTO);
            _context.Customers.Add(customer);
            _context.SaveChanges();

            // After save it this Customer object has Id generated from DB and we will add it to DTO and return it to the client
            // Now the Id prop will set based on the Id generated from the database
            customerDTO.Id = customer.Id;

            // return customerDTO;
            // Based on REST convention we must return theuri of the newly created resource to the client
            // if id is 10 --> api/customers/10
            // to get it we used the Request prop of the controller, 2nd arg is the actual object that was created
            // This will return the new object created with location in header that have the uri
            return Created(new Uri(Request.RequestUri + "/" + customer.Id), customerDTO);
        }

        // PUT: /api/customers/1
        // We can return a customer or void
        // We need two params.: id which is read from the url, and customr which come from request body
        [HttpPut]
        public void UpdateCustomer(int id, CustomerDTO customerDTO)
        {
            // Check for validate
            if (!ModelState.IsValid)
            {
                // By convention server error [400]
                throw new HttpResponseException(HttpStatusCode.BadRequest);
            }

            // Get data from DB
            var customerInDb = _context.Customers.SingleOrDefault(c => c.Id == id);
            // If client send invalid id
            if (customerInDb == null)
            {
                throw new HttpResponseException(HttpStatusCode.NotFound);
            }

            // Everything is good
            // We can use AutoMapper here
            //customerInDb.Name = customerDTO.Name;
            //customerInDb.Birthdate = customerDTO.Birthdate;
            //customerInDb.IsSubscribedToNewsletters = customerDTO.IsSubscribedToNewsletters;
            //customerInDb.MembershipTypeId = customerDTO.MembershipTypeId;

            // Here it take source obj and target obj in () so here it's not return a new obj cuz we have exist obj, and the context can track changes on it
            // and here the generic parameter <> is gradeout cuz compiler can infer from the () the source and target types
            // <CustomerDTO, Customer>
            Mapper.Map(customerDTO, customerInDb);

            _context.SaveChanges();
        }

        // Delete: /api/customers/1
        [HttpDelete]
        public void DeleteCustomer(int id)
        {
            // Get data from DB
            var customerInDb = _context.Customers.SingleOrDefault(c => c.Id == id);
            // If client send invalid id
            if (customerInDb == null)
            {
                throw new HttpResponseException(HttpStatusCode.NotFound);
            }

            // Here obj will be marked is removed in memory
            _context.Customers.Remove(customerInDb);
            // Then save
            _context.SaveChanges();
        }
    }
}
